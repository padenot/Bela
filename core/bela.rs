/* automatically generated by rust-bindgen */

#[allow(non_snake_case_functions)]

#[derive(Copy, Debug)]
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _ISOC95_SOURCE: ::std::os::raw::c_uint = 1;
pub const _ISOC99_SOURCE: ::std::os::raw::c_uint = 1;
pub const _ISOC11_SOURCE: ::std::os::raw::c_uint = 1;
pub const _XOPEN_SOURCE: ::std::os::raw::c_uint = 700;
pub const _XOPEN_SOURCE_EXTENDED: ::std::os::raw::c_uint = 1;
pub const _LARGEFILE64_SOURCE: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const _BSD_SOURCE: ::std::os::raw::c_uint = 1;
pub const _SVID_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN_EXTENDED: ::std::os::raw::c_uint = 1;
pub const __USE_UNIX98: ::std::os::raw::c_uint = 1;
pub const _LARGEFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8XSI: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2KXSI: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_LARGEFILE: ::std::os::raw::c_uint = 1;
pub const __USE_LARGEFILE64: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_BSD: ::std::os::raw::c_uint = 1;
pub const __USE_SVID: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_GNU: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 19;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const _UNISTD_H: ::std::os::raw::c_uint = 1;
pub const _XOPEN_VERSION: ::std::os::raw::c_uint = 700;
pub const _XOPEN_XCU_VERSION: ::std::os::raw::c_uint = 4;
pub const _XOPEN_XPG2: ::std::os::raw::c_uint = 1;
pub const _XOPEN_XPG3: ::std::os::raw::c_uint = 1;
pub const _XOPEN_XPG4: ::std::os::raw::c_uint = 1;
pub const _XOPEN_UNIX: ::std::os::raw::c_uint = 1;
pub const _XOPEN_CRYPT: ::std::os::raw::c_uint = 1;
pub const _XOPEN_ENH_I18N: ::std::os::raw::c_uint = 1;
pub const _XOPEN_LEGACY: ::std::os::raw::c_uint = 1;
pub const _BITS_POSIX_OPT_H: ::std::os::raw::c_uint = 1;
pub const _POSIX_JOB_CONTROL: ::std::os::raw::c_uint = 1;
pub const _POSIX_SAVED_IDS: ::std::os::raw::c_uint = 1;
pub const _POSIX_CHOWN_RESTRICTED: ::std::os::raw::c_uint = 0;
pub const _POSIX_NO_TRUNC: ::std::os::raw::c_uint = 1;
pub const _XOPEN_REALTIME: ::std::os::raw::c_uint = 1;
pub const _XOPEN_REALTIME_THREADS: ::std::os::raw::c_uint = 1;
pub const _XOPEN_SHM: ::std::os::raw::c_uint = 1;
pub const _POSIX_REENTRANT_FUNCTIONS: ::std::os::raw::c_uint = 1;
pub const _POSIX_ASYNC_IO: ::std::os::raw::c_uint = 1;
pub const _LFS_ASYNCHRONOUS_IO: ::std::os::raw::c_uint = 1;
pub const _LFS64_ASYNCHRONOUS_IO: ::std::os::raw::c_uint = 1;
pub const _LFS_LARGEFILE: ::std::os::raw::c_uint = 1;
pub const _LFS64_LARGEFILE: ::std::os::raw::c_uint = 1;
pub const _LFS64_STDIO: ::std::os::raw::c_uint = 1;
pub const _POSIX_CPUTIME: ::std::os::raw::c_uint = 0;
pub const _POSIX_THREAD_CPUTIME: ::std::os::raw::c_uint = 0;
pub const _POSIX_REGEXP: ::std::os::raw::c_uint = 1;
pub const _POSIX_SHELL: ::std::os::raw::c_uint = 1;
pub const _POSIX_MONOTONIC_CLOCK: ::std::os::raw::c_uint = 0;
pub const _POSIX_V7_LP64_OFF64: ::std::os::raw::c_uint = 1;
pub const _POSIX_V6_LP64_OFF64: ::std::os::raw::c_uint = 1;
pub const _XBS5_LP64_OFF64: ::std::os::raw::c_uint = 1;
pub const STDIN_FILENO: ::std::os::raw::c_uint = 0;
pub const STDOUT_FILENO: ::std::os::raw::c_uint = 1;
pub const STDERR_FILENO: ::std::os::raw::c_uint = 2;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const R_OK: ::std::os::raw::c_uint = 4;
pub const W_OK: ::std::os::raw::c_uint = 2;
pub const X_OK: ::std::os::raw::c_uint = 1;
pub const F_OK: ::std::os::raw::c_uint = 0;
pub const F_ULOCK: ::std::os::raw::c_uint = 0;
pub const F_LOCK: ::std::os::raw::c_uint = 1;
pub const F_TLOCK: ::std::os::raw::c_uint = 2;
pub const F_TEST: ::std::os::raw::c_uint = 3;
pub const _STDIO_H: ::std::os::raw::c_uint = 1;
pub const __FILE_defined: ::std::os::raw::c_uint = 1;
pub const ____FILE_defined: ::std::os::raw::c_uint = 1;
pub const _G_config_h: ::std::os::raw::c_uint = 1;
pub const ____mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MMAP: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MREMAP: ::std::os::raw::c_uint = 1;
pub const _G_IO_IO_FILE_VERSION: ::std::os::raw::c_uint = 131073;
pub const _G_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const _IO_UNIFIED_JUMPTABLES: ::std::os::raw::c_uint = 1;
pub const _IOS_INPUT: ::std::os::raw::c_uint = 1;
pub const _IOS_OUTPUT: ::std::os::raw::c_uint = 2;
pub const _IOS_ATEND: ::std::os::raw::c_uint = 4;
pub const _IOS_APPEND: ::std::os::raw::c_uint = 8;
pub const _IOS_TRUNC: ::std::os::raw::c_uint = 16;
pub const _IOS_NOCREATE: ::std::os::raw::c_uint = 32;
pub const _IOS_NOREPLACE: ::std::os::raw::c_uint = 64;
pub const _IOS_BIN: ::std::os::raw::c_uint = 128;
pub const _IO_MAGIC: ::std::os::raw::c_uint = 4222418944;
pub const _OLD_STDIO_MAGIC: ::std::os::raw::c_uint = 4206624768;
pub const _IO_MAGIC_MASK: ::std::os::raw::c_uint = 4294901760;
pub const _IO_USER_BUF: ::std::os::raw::c_uint = 1;
pub const _IO_UNBUFFERED: ::std::os::raw::c_uint = 2;
pub const _IO_NO_READS: ::std::os::raw::c_uint = 4;
pub const _IO_NO_WRITES: ::std::os::raw::c_uint = 8;
pub const _IO_EOF_SEEN: ::std::os::raw::c_uint = 16;
pub const _IO_ERR_SEEN: ::std::os::raw::c_uint = 32;
pub const _IO_DELETE_DONT_CLOSE: ::std::os::raw::c_uint = 64;
pub const _IO_LINKED: ::std::os::raw::c_uint = 128;
pub const _IO_IN_BACKUP: ::std::os::raw::c_uint = 256;
pub const _IO_LINE_BUF: ::std::os::raw::c_uint = 512;
pub const _IO_TIED_PUT_GET: ::std::os::raw::c_uint = 1024;
pub const _IO_CURRENTLY_PUTTING: ::std::os::raw::c_uint = 2048;
pub const _IO_IS_APPENDING: ::std::os::raw::c_uint = 4096;
pub const _IO_IS_FILEBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_BAD_SEEN: ::std::os::raw::c_uint = 16384;
pub const _IO_USER_LOCK: ::std::os::raw::c_uint = 32768;
pub const _IO_FLAGS2_MMAP: ::std::os::raw::c_uint = 1;
pub const _IO_FLAGS2_NOTCANCEL: ::std::os::raw::c_uint = 2;
pub const _IO_FLAGS2_USER_WBUF: ::std::os::raw::c_uint = 8;
pub const _IO_SKIPWS: ::std::os::raw::c_uint = 1;
pub const _IO_LEFT: ::std::os::raw::c_uint = 2;
pub const _IO_RIGHT: ::std::os::raw::c_uint = 4;
pub const _IO_INTERNAL: ::std::os::raw::c_uint = 10;
pub const _IO_DEC: ::std::os::raw::c_uint = 20;
pub const _IO_OCT: ::std::os::raw::c_uint = 40;
pub const _IO_HEX: ::std::os::raw::c_uint = 100;
pub const _IO_SHOWBASE: ::std::os::raw::c_uint = 200;
pub const _IO_SHOWPOINT: ::std::os::raw::c_uint = 400;
pub const _IO_UPPERCASE: ::std::os::raw::c_uint = 1000;
pub const _IO_SHOWPOS: ::std::os::raw::c_uint = 2000;
pub const _IO_SCIENTIFIC: ::std::os::raw::c_uint = 4000;
pub const _IO_FIXED: ::std::os::raw::c_uint = 10000;
pub const _IO_UNITBUF: ::std::os::raw::c_uint = 20000;
pub const _IO_STDIO: ::std::os::raw::c_uint = 40000;
pub const _IO_DONT_CLOSE: ::std::os::raw::c_uint = 100000;
pub const _IO_BOOLALPHA: ::std::os::raw::c_uint = 200000;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const SEEK_DATA: ::std::os::raw::c_uint = 3;
pub const SEEK_HOLE: ::std::os::raw::c_uint = 4;
pub const L_tmpnam: ::std::os::raw::c_uint = 20;
pub const TMP_MAX: ::std::os::raw::c_uint = 238328;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 4096;
pub const L_ctermid: ::std::os::raw::c_uint = 9;
pub const L_cuserid: ::std::os::raw::c_uint = 9;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 16;
pub const CONFIG_MMU: ::std::os::raw::c_uint = 1;
pub const CONFIG_SMP: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_TSC: ::std::os::raw::c_uint = 1;
pub const CONFIG_XENO_ATOMIC_BUILTINS: ::std::os::raw::c_uint = 1;
pub const CONFIG_XENO_DEFAULT_PERIOD: ::std::os::raw::c_uint = 1000000;
pub const CONFIG_XENO_FORTIFY: ::std::os::raw::c_uint = 1;
pub const CONFIG_XENO_REVISION_LEVEL: ::std::os::raw::c_uint = 3;
pub const CONFIG_XENO_VERSION_MAJOR: ::std::os::raw::c_uint = 2;
pub const CONFIG_XENO_VERSION_MINOR: ::std::os::raw::c_uint = 6;
pub const CONFIG_XENO_X86_SEP: ::std::os::raw::c_uint = 1;
pub const NUM_DIGITALS: ::std::os::raw::c_uint = 16;
pub const GPIO_INPUT: ::std::os::raw::c_uint = 1;
pub const GPIO_OUTPUT: ::std::os::raw::c_uint = 0;
pub const GPIO_HIGH: ::std::os::raw::c_uint = 1;
pub const GPIO_LOW: ::std::os::raw::c_uint = 0;
pub const P8_07_GPIO_NO: ::std::os::raw::c_uint = 66;
pub const P8_08_GPIO_NO: ::std::os::raw::c_uint = 67;
pub const P8_09_GPIO_NO: ::std::os::raw::c_uint = 69;
pub const P8_10_GPIO_NO: ::std::os::raw::c_uint = 68;
pub const P8_11_GPIO_NO: ::std::os::raw::c_uint = 45;
pub const P8_12_GPIO_NO: ::std::os::raw::c_uint = 44;
pub const P9_12_GPIO_NO: ::std::os::raw::c_uint = 60;
pub const P9_14_GPIO_NO: ::std::os::raw::c_uint = 50;
pub const P8_15_GPIO_NO: ::std::os::raw::c_uint = 47;
pub const P8_16_GPIO_NO: ::std::os::raw::c_uint = 46;
pub const P9_16_GPIO_NO: ::std::os::raw::c_uint = 51;
pub const P8_18_GPIO_NO: ::std::os::raw::c_uint = 65;
pub const P8_27_GPIO_NO: ::std::os::raw::c_uint = 86;
pub const P8_28_GPIO_NO: ::std::os::raw::c_uint = 88;
pub const P8_29_GPIO_NO: ::std::os::raw::c_uint = 87;
pub const P8_30_GPIO_NO: ::std::os::raw::c_uint = 89;
pub const P8_07: ::std::os::raw::c_uint = 0;
pub const P8_08: ::std::os::raw::c_uint = 1;
pub const P8_09: ::std::os::raw::c_uint = 2;
pub const P8_10: ::std::os::raw::c_uint = 3;
pub const P8_11: ::std::os::raw::c_uint = 4;
pub const P8_12: ::std::os::raw::c_uint = 5;
pub const P9_12: ::std::os::raw::c_uint = 6;
pub const P9_14: ::std::os::raw::c_uint = 7;
pub const P8_15: ::std::os::raw::c_uint = 8;
pub const P8_16: ::std::os::raw::c_uint = 9;
pub const P9_16: ::std::os::raw::c_uint = 10;
pub const P8_18: ::std::os::raw::c_uint = 11;
pub const P8_27: ::std::os::raw::c_uint = 12;
pub const P8_28: ::std::os::raw::c_uint = 13;
pub const P8_29: ::std::os::raw::c_uint = 14;
pub const P8_30: ::std::os::raw::c_uint = 15;
pub const MAX_BUF: ::std::os::raw::c_uint = 128;
pub const CODEC_I2C_ADDRESS: ::std::os::raw::c_uint = 24;
pub const MAX_PRU_FILENAME_LENGTH: ::std::os::raw::c_uint = 256;
pub const MAX_SERVERNAME_LENGTH: ::std::os::raw::c_uint = 256;
pub const BELA_AUDIO_PRIORITY: ::std::os::raw::c_uint = 95;
pub const DEFAULT_PGA_GAIN: ::std::os::raw::c_uint = 16;
pub const INPUT: ::std::os::raw::c_uint = 0;
pub const OUTPUT: ::std::os::raw::c_uint = 1;
pub type i8 = ::std::os::raw::c_char;
pub type i16 = ::std::os::raw::c_short;
pub type i32 = ::std::os::raw::c_int;
pub type i64 = ::std::os::raw::c_long;
pub type u8 = ::std::os::raw::c_uchar;
pub type u16 = ::std::os::raw::c_ushort;
pub type u32 = ::std::os::raw::c_uint;
pub type u64 = ::std::os::raw::c_ulong;
pub type int_least8_t = ::std::os::raw::c_char;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_char;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Struct_types_h_unnamed_1 {
    pub __val: [::std::os::raw::c_int; 2usize],
}
impl ::std::clone::Clone for Struct_types_h_unnamed_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Struct_types_h_unnamed_1() {
    assert_eq!(::std::mem::size_of::<Struct_types_h_unnamed_1>() , 8usize);
    assert_eq!(::std::mem::align_of::<Struct_types_h_unnamed_1>() , 4usize);
}
pub type __fsid_t = Struct_types_h_unnamed_1;
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type isize = __ssize_t;
pub type usize = ::std::os::raw::c_ulong;
pub type gid_t = __gid_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type useconds_t = __useconds_t;
pub type pid_t = __pid_t;
pub type socklen_t = __socklen_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Enum_confname_h_unnamed_2 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20,
}
pub const _SC_IOV_MAX: Enum_confname_h_unnamed_3 =
    Enum_confname_h_unnamed_3::_SC_UIO_MAXIOV;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Enum_confname_h_unnamed_3 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Enum_confname_h_unnamed_4 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149,
}
pub type FILE = Struct__IO_FILE;
pub type __FILE = Struct__IO_FILE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Struct_wchar_h_unnamed_5 {
    pub __count: ::std::os::raw::c_int,
    pub __value: Union_wchar_h_unnamed_5_wchar_h_unnamed_6,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Union_wchar_h_unnamed_5_wchar_h_unnamed_6 {
    pub __wch: __BindgenUnionField<::std::os::raw::c_uint>,
    pub __wchb: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub _bindgen_data_: u32,
}
impl Union_wchar_h_unnamed_5_wchar_h_unnamed_6 {
    pub unsafe fn __wch(&mut self) -> *mut ::std::os::raw::c_uint {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __wchb(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_wchar_h_unnamed_5_wchar_h_unnamed_6 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Union_wchar_h_unnamed_5_wchar_h_unnamed_6() {
    assert_eq!(::std::mem::size_of::<Union_wchar_h_unnamed_5_wchar_h_unnamed_6>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<Union_wchar_h_unnamed_5_wchar_h_unnamed_6>()
               , 4usize);
}
impl ::std::clone::Clone for Struct_wchar_h_unnamed_5 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Struct_wchar_h_unnamed_5() {
    assert_eq!(::std::mem::size_of::<Struct_wchar_h_unnamed_5>() , 8usize);
    assert_eq!(::std::mem::align_of::<Struct_wchar_h_unnamed_5>() , 4usize);
}
pub type __mbstate_t = Struct_wchar_h_unnamed_5;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Struct__G_config_h_unnamed_7 {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
impl ::std::clone::Clone for Struct__G_config_h_unnamed_7 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Struct__G_config_h_unnamed_7() {
    assert_eq!(::std::mem::size_of::<Struct__G_config_h_unnamed_7>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<Struct__G_config_h_unnamed_7>() ,
               8usize);
}
pub type _G_fpos_t = Struct__G_config_h_unnamed_7;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Struct__G_config_h_unnamed_8 {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
impl ::std::clone::Clone for Struct__G_config_h_unnamed_8 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Struct__G_config_h_unnamed_8() {
    assert_eq!(::std::mem::size_of::<Struct__G_config_h_unnamed_8>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<Struct__G_config_h_unnamed_8>() ,
               8usize);
}
pub type _G_fpos64_t = Struct__G_config_h_unnamed_8;
pub enum Struct__IO_jump_t { }
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Struct__IO_marker {
    pub _next: *mut Struct__IO_marker,
    pub _sbuf: *mut Struct__IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct__IO_marker {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Struct__IO_marker() {
    assert_eq!(::std::mem::size_of::<Struct__IO_marker>() , 24usize);
    assert_eq!(::std::mem::align_of::<Struct__IO_marker>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Enum___codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Struct__IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut Struct__IO_marker,
    pub _chain: *mut Struct__IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_char,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
impl ::std::clone::Clone for Struct__IO_FILE {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Struct__IO_FILE() {
    assert_eq!(::std::mem::size_of::<Struct__IO_FILE>() , 216usize);
    assert_eq!(::std::mem::align_of::<Struct__IO_FILE>() , 8usize);
}
pub enum Struct__IO_FILE_plus { }
pub type __io_read_fn =
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void,
                         __buf: *mut ::std::os::raw::c_char, __nbytes: usize)
        -> __ssize_t;
pub type __io_write_fn =
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void,
                         __buf: *const ::std::os::raw::c_char, __n: usize)
        -> __ssize_t;
pub type __io_seek_fn =
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void,
                         __pos: *mut __off64_t, __w: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
pub type __io_close_fn =
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
pub type cookie_read_function_t = __io_read_fn;
pub type cookie_write_function_t = __io_write_fn;
pub type cookie_seek_function_t = __io_seek_fn;
pub type cookie_close_function_t = __io_close_fn;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Struct_libio_h_unnamed_9 {
    pub read: *mut ::std::option::Option<unsafe extern "C" fn() -> __ssize_t>,
    pub write: *mut ::std::option::Option<unsafe extern "C" fn()
                                              -> __ssize_t>,
    pub seek: *mut ::std::option::Option<unsafe extern "C" fn()
                                             -> ::std::os::raw::c_int>,
    pub close: *mut ::std::option::Option<unsafe extern "C" fn()
                                              -> ::std::os::raw::c_int>,
}
impl ::std::clone::Clone for Struct_libio_h_unnamed_9 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Struct_libio_h_unnamed_9() {
    assert_eq!(::std::mem::size_of::<Struct_libio_h_unnamed_9>() , 32usize);
    assert_eq!(::std::mem::align_of::<Struct_libio_h_unnamed_9>() , 8usize);
}
pub type _IO_cookie_io_functions_t = Struct_libio_h_unnamed_9;
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub enum Struct__IO_cookie_file { }
pub type fpos_t = _G_fpos_t;
pub type fpos64_t = _G_fpos64_t;
pub enum Struct_obstack { }
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Enum_PIN_DIRECTION { INPUT_PIN = 0, OUTPUT_PIN = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum Enum_PIN_VALUE { LOW = 0, HIGH = 1, }
/**
 * \ingroup control
 * \brief Structure containing initialisation parameters for the real-time
 * audio control system.
 *
 * This structure is initialised using Bela_defaultSettings(). Its contents
 * are used up through the point of calling
 * Bela_initAudio() at which point it is no longer needed.
 */
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Bela_h_unnamed_10 {
    /// \brief Number of (analog) frames per period.
	///
	/// Number of audio frames depends on relative sample rates of the two. By default,
	/// audio is twice the sample rate, so has twice the period size.
    pub periodSize: ::std::os::raw::c_int,
    /// Whether to use the analog input and output
    pub useAnalog: ::std::os::raw::c_int,
    /// Whether to use the 16 programmable GPIOs
    pub useDigital: ::std::os::raw::c_int,
    /// How many audio input channels
    pub numAudioInChannels: ::std::os::raw::c_int,
    /// How many audio out channels
    pub numAudioOutChannels: ::std::os::raw::c_int,
    /// How many analog input channels
    pub numAnalogInChannels: ::std::os::raw::c_int,
    /// How many analog output channels
    pub numAnalogOutChannels: ::std::os::raw::c_int,
    /// How many channels for the GPIOs
    pub numDigitalChannels: ::std::os::raw::c_int,
    /// Whether to begin with the speakers muted
    pub beginMuted: ::std::os::raw::c_int,
    /// Level for the audio DAC output
    pub dacLevel: f32,
    /// Level for the audio ADC input
    pub adcLevel: f32,
    /// Gains for the PGA, left and right channels
    pub pgaGain: [f32; 2usize],
    /// Level for the headphone output
    pub headphoneLevel: f32,
    /// How many channels to use on the multiplexer capelet, if enabled
    pub numMuxChannels: ::std::os::raw::c_int,
    /// Which PRU (0 or 1) the code should run on
    pub pruNumber: ::std::os::raw::c_int,
    /// The external .bin file to load. If empty will use PRU code from pru_rtaudio_bin.h
    pub pruFilename: [::std::os::raw::c_char; 256usize],
    /// Whether to use verbose logging
    pub verbose: ::std::os::raw::c_int,
    /// Whether audio/analog data should be interleaved
    pub interleave: ::std::os::raw::c_int,
    /// \brief Whether analog outputs should persist to future frames.
	///
	/// n.b. digital pins always persist, audio never does
    pub analogOutputsPersist: ::std::os::raw::c_int,
    /// Where the codec can be found on the I2C bus
    pub codecI2CAddress: ::std::os::raw::c_int,
    /// Pin where amplifier mute can be found
    pub ampMutePin: ::std::os::raw::c_int,
    /// Port where the UDP server will listen
    pub receivePort: ::std::os::raw::c_int,
    /// Port where the UDP client will transmit
    pub transmitPort: ::std::os::raw::c_int,
    pub serverName: [::std::os::raw::c_char; 256usize],
}
impl ::std::clone::Clone for Struct_Bela_h_unnamed_10 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Struct_Bela_h_unnamed_10() {
    assert_eq!(::std::mem::size_of::<Struct_Bela_h_unnamed_10>() , 604usize);
    assert_eq!(::std::mem::align_of::<Struct_Bela_h_unnamed_10>() , 4usize);
}
pub type BelaInitSettings = Struct_Bela_h_unnamed_10;
/**
 * \ingroup render
 * \brief Structure holding current audio and sensor settings and pointers to data buffers.
 *
 * This structure is passed to setup(), render() and cleanup(). It is
 * initialised in Bela_initAudio() based on the contents of the BelaInitSettings
 * structure.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Struct_Bela_h_unnamed_11 {
    /// \brief Buffer holding audio input samples
	///
	/// This buffer may be in either interleaved or non-interleaved format,
	/// depending on the contents of the BelaInitSettings structure.
	/// \b Note: this element is available in render() only.
    pub audioIn: *const f32,
    /// \brief Buffer holding audio output samples
	///
	/// This buffer may be in either interleaved or non-interleaved format,
	/// depending on the contents of the BelaInitSettings structure.
	/// \b Note: this element is available in render() only.
    pub audioOut: *mut f32,
    /// \brief Buffer holding analog input samples
	///
	/// This buffer may be in either interleaved or non-interleaved format,
	/// depending on the contents of the BelaInitSettings structure.
	/// \b Note: this element is available in render() only.
    pub analogIn: *const f32,
    /// \brief Buffer holding analog output samples
	///
	/// This buffer may be in either interleaved or non-interleaved format,
	/// depending on the contents of the BelaInitSettings structure.
	/// \b Note: this element is available in render() only.
    pub analogOut: *mut f32,
    /// \brief Buffer holding digital input/output samples
	///
	/// \b Note: this element is available in render() only.
    pub digital: *mut u32,
    /// Number of audio frames per period
    pub audioFrames: u32,
    /// Number of input audio channels
    pub audioInChannels: u32,
    /// Number of output audio channels
    pub audioOutChannels: u32,
    /// Audio sample rate in Hz (currently always 44100.0)
    pub audioSampleRate: f32,
    /// \brief Number of analog frames per period
	///
	/// This will be 0 if analog I/O is disabled.
    pub analogFrames: u32,
    /// \brief Number of input analog channels
	///
	/// This will be 0 if analog I/O is disabled.
    pub analogInChannels: u32,
    /// \brief Number of output analog channels
	///
	/// This will be 0 if analog I/O is disabled.
    pub analogOutChannels: u32,
    /// \brief Analog sample rate in Hz
	///
	/// The analog sample rate depends on the number of analog channels used. If
	/// 8 channels are used, the sample rate is 22050. If 4 channels are used, the sample
	/// rate is 44100. If 2 channels are used, the sample rate is 88200. If analog I/O
	/// is disabled, the sample rate is 0.
    pub analogSampleRate: f32,
    /// Number of digital frames per period
    pub digitalFrames: u32,
    /// \brief Number of digital channels
	///
	/// Currently this will always be 16, unless digital I/O is disabled, in which case it will be 0.
    pub digitalChannels: u32,
    /// Digital sample rate in Hz (currently always 44100.0)
    pub digitalSampleRate: f32,
    /// \brief Number of elapsed audio frames since the start of rendering.
	///
	/// This holds the total number of audio frames as of the beginning of the current period. To
	/// find the current number of analog or digital frames elapsed, multiply by the ratio of the
	/// sample rates (e.g. half the number of analog frames will have elapsed if the analog sample
	/// rate is 22050).
    pub audioFramesElapsed: u64,
    /// \brief Other audio/sensor settings
	///
	/// Binary combination of flags including:
	///
	/// BELA_FLAG_INTERLEAVED: indicates the audio and analog buffers are interleaved
	///
	/// BELA_FLAG_ANALOG_OUTPUTS_PERSIST: indicates that writes to the analog outputs will
	/// persist for future frames. If not set, writes affect one frame only.
    pub flags: u32,
}
impl ::std::clone::Clone for Struct_Bela_h_unnamed_11 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Struct_Bela_h_unnamed_11() {
    assert_eq!(::std::mem::size_of::<Struct_Bela_h_unnamed_11>() , 104usize);
    assert_eq!(::std::mem::align_of::<Struct_Bela_h_unnamed_11>() , 8usize);
}
pub type BelaContext = Struct_Bela_h_unnamed_11;
/** \ingroup auxtask
 *
 * Auxiliary task variable. Auxiliary tasks are created using createAuxiliaryTask() and
 * automatically cleaned up after cleanup() finishes.
 */
pub type AuxiliaryTask = *mut ::std::os::raw::c_void;
pub enum Struct_option { }
extern "C" {
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
    pub static mut environ: *mut *mut ::std::os::raw::c_char;
    pub static mut optarg: *mut ::std::os::raw::c_char;
    pub static mut optind: ::std::os::raw::c_int;
    pub static mut opterr: ::std::os::raw::c_int;
    pub static mut optopt: ::std::os::raw::c_int;
    pub static mut _IO_2_1_stdin_: Struct__IO_FILE_plus;
    pub static mut _IO_2_1_stdout_: Struct__IO_FILE_plus;
    pub static mut _IO_2_1_stderr_: Struct__IO_FILE_plus;
    pub static mut stdin: Struct__IO_FILE;
    pub static mut stdout: Struct__IO_FILE;
    pub static mut stderr: Struct__IO_FILE;
    pub static mut sys_nerr: ::std::os::raw::c_int;
    pub static mut sys_errlist: *const *const ::std::os::raw::c_char;
    pub static mut _sys_nerr: ::std::os::raw::c_int;
    pub static mut _sys_errlist: *const *const ::std::os::raw::c_char;
    pub static mut digitalPins: [::std::os::raw::c_short; 16usize];
    pub static mut gShouldStop: ::std::os::raw::c_int;
}
extern "C" {
    pub fn access(__name: *const ::std::os::raw::c_char,
                  __type: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn euidaccess(__name: *const ::std::os::raw::c_char,
                      __type: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn eaccess(__name: *const ::std::os::raw::c_char,
                   __type: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn faccessat(__fd: ::std::os::raw::c_int,
                     __file: *const ::std::os::raw::c_char,
                     __type: ::std::os::raw::c_int,
                     __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn lseek(__fd: ::std::os::raw::c_int, __offset: __off_t,
                 __whence: ::std::os::raw::c_int) -> __off_t;
    pub fn lseek64(__fd: ::std::os::raw::c_int, __offset: __off64_t,
                   __whence: ::std::os::raw::c_int) -> __off64_t;
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn read(__fd: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_void, __nbytes: usize) -> isize;
    pub fn write(__fd: ::std::os::raw::c_int,
                 __buf: *const ::std::os::raw::c_void, __n: usize) -> isize;
    pub fn pread(__fd: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_void, __nbytes: usize,
                 __offset: __off_t) -> isize;
    pub fn pwrite(__fd: ::std::os::raw::c_int,
                  __buf: *const ::std::os::raw::c_void, __n: usize,
                  __offset: __off_t) -> isize;
    pub fn pread64(__fd: ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_void, __nbytes: usize,
                   __offset: __off64_t) -> isize;
    pub fn pwrite64(__fd: ::std::os::raw::c_int,
                    __buf: *const ::std::os::raw::c_void, __n: usize,
                    __offset: __off64_t) -> isize;
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pipe2(__pipedes: *mut ::std::os::raw::c_int,
                 __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t)
     -> __useconds_t;
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
    pub fn pause() -> ::std::os::raw::c_int;
    pub fn chown(__file: *const ::std::os::raw::c_char, __owner: __uid_t,
                 __group: __gid_t) -> ::std::os::raw::c_int;
    pub fn fchown(__fd: ::std::os::raw::c_int, __owner: __uid_t,
                  __group: __gid_t) -> ::std::os::raw::c_int;
    pub fn lchown(__file: *const ::std::os::raw::c_char, __owner: __uid_t,
                  __group: __gid_t) -> ::std::os::raw::c_int;
    pub fn fchownat(__fd: ::std::os::raw::c_int,
                    __file: *const ::std::os::raw::c_char, __owner: __uid_t,
                    __group: __gid_t, __flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn chdir(__path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
     -> *mut ::std::os::raw::c_char;
    pub fn get_current_dir_name() -> *mut ::std::os::raw::c_char;
    pub fn getwd(__buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn dup3(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int,
                __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn execve(__path: *const ::std::os::raw::c_char,
                  __argv: *const *mut ::std::os::raw::c_char,
                  __envp: *const *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn fexecve(__fd: ::std::os::raw::c_int,
                   __argv: *const *mut ::std::os::raw::c_char,
                   __envp: *const *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn execv(__path: *const ::std::os::raw::c_char,
                 __argv: *const *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn execle(__path: *const ::std::os::raw::c_char,
                  __arg: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn execl(__path: *const ::std::os::raw::c_char,
                 __arg: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn execvp(__file: *const ::std::os::raw::c_char,
                  __argv: *const *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn execlp(__file: *const ::std::os::raw::c_char,
                  __arg: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn execvpe(__file: *const ::std::os::raw::c_char,
                   __argv: *const *mut ::std::os::raw::c_char,
                   __envp: *const *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn _exit(__status: ::std::os::raw::c_int);
    pub fn pathconf(__path: *const ::std::os::raw::c_char,
                    __name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
    pub fn fpathconf(__fd: ::std::os::raw::c_int,
                     __name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
    pub fn confstr(__name: ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize) -> usize;
    pub fn getpid() -> __pid_t;
    pub fn getppid() -> __pid_t;
    pub fn getpgrp() -> __pid_t;
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
    pub fn setpgrp() -> ::std::os::raw::c_int;
    pub fn setsid() -> __pid_t;
    pub fn getsid(__pid: __pid_t) -> __pid_t;
    pub fn getuid() -> __uid_t;
    pub fn geteuid() -> __uid_t;
    pub fn getgid() -> __gid_t;
    pub fn getegid() -> __gid_t;
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t)
     -> ::std::os::raw::c_int;
    pub fn group_member(__gid: __gid_t) -> ::std::os::raw::c_int;
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t)
     -> ::std::os::raw::c_int;
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t)
     -> ::std::os::raw::c_int;
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
    pub fn getresuid(__ruid: *mut __uid_t, __euid: *mut __uid_t,
                     __suid: *mut __uid_t) -> ::std::os::raw::c_int;
    pub fn getresgid(__rgid: *mut __gid_t, __egid: *mut __gid_t,
                     __sgid: *mut __gid_t) -> ::std::os::raw::c_int;
    pub fn setresuid(__ruid: __uid_t, __euid: __uid_t, __suid: __uid_t)
     -> ::std::os::raw::c_int;
    pub fn setresgid(__rgid: __gid_t, __egid: __gid_t, __sgid: __gid_t)
     -> ::std::os::raw::c_int;
    pub fn fork() -> __pid_t;
    pub fn vfork() -> __pid_t;
    pub fn ttyname(__fd: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn ttyname_r(__fd: ::std::os::raw::c_int,
                     __buf: *mut ::std::os::raw::c_char, __buflen: usize)
     -> ::std::os::raw::c_int;
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ttyslot() -> ::std::os::raw::c_int;
    pub fn link(__from: *const ::std::os::raw::c_char,
                __to: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn linkat(__fromfd: ::std::os::raw::c_int,
                  __from: *const ::std::os::raw::c_char,
                  __tofd: ::std::os::raw::c_int,
                  __to: *const ::std::os::raw::c_char,
                  __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn symlink(__from: *const ::std::os::raw::c_char,
                   __to: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn readlink(__path: *const ::std::os::raw::c_char,
                    __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> isize;
    pub fn symlinkat(__from: *const ::std::os::raw::c_char,
                     __tofd: ::std::os::raw::c_int,
                     __to: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn readlinkat(__fd: ::std::os::raw::c_int,
                      __path: *const ::std::os::raw::c_char,
                      __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> isize;
    pub fn unlink(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn unlinkat(__fd: ::std::os::raw::c_int,
                    __name: *const ::std::os::raw::c_char,
                    __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rmdir(__path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t)
     -> ::std::os::raw::c_int;
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
    pub fn getlogin_r(__name: *mut ::std::os::raw::c_char, __name_len: usize)
     -> ::std::os::raw::c_int;
    pub fn setlogin(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getopt(___argc: ::std::os::raw::c_int,
                  ___argv: *const *mut ::std::os::raw::c_char,
                  __shortopts: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
    pub fn sethostname(__name: *const ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
    pub fn getdomainname(__name: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
    pub fn setdomainname(__name: *const ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
    pub fn vhangup() -> ::std::os::raw::c_int;
    pub fn revoke(__file: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn profil(__sample_buffer: *mut ::std::os::raw::c_ushort,
                  __size: usize, __offset: usize,
                  __scale: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    pub fn acct(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
    pub fn endusershell();
    pub fn setusershell();
    pub fn daemon(__nochdir: ::std::os::raw::c_int,
                  __noclose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn chroot(__path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getpass(__prompt: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn syncfs(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn gethostid() -> ::std::os::raw::c_long;
    pub fn sync();
    pub fn getpagesize() -> ::std::os::raw::c_int;
    pub fn getdtablesize() -> ::std::os::raw::c_int;
    pub fn truncate(__file: *const ::std::os::raw::c_char, __length: __off_t)
     -> ::std::os::raw::c_int;
    pub fn truncate64(__file: *const ::std::os::raw::c_char,
                      __length: __off64_t) -> ::std::os::raw::c_int;
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t)
     -> ::std::os::raw::c_int;
    pub fn ftruncate64(__fd: ::std::os::raw::c_int, __length: __off64_t)
     -> ::std::os::raw::c_int;
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...)
     -> ::std::os::raw::c_long;
    pub fn lockf(__fd: ::std::os::raw::c_int, __cmd: ::std::os::raw::c_int,
                 __len: __off_t) -> ::std::os::raw::c_int;
    pub fn lockf64(__fd: ::std::os::raw::c_int, __cmd: ::std::os::raw::c_int,
                   __len: __off64_t) -> ::std::os::raw::c_int;
    pub fn fdatasync(__fildes: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn crypt(__key: *const ::std::os::raw::c_char,
                 __salt: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn encrypt(__glibc_block: *mut ::std::os::raw::c_char,
                   __edflag: ::std::os::raw::c_int);
    pub fn swab(__from: *const ::std::os::raw::c_void,
                __to: *mut ::std::os::raw::c_void, __n: isize);
    pub fn _IO_cookie_init(__cfile: *mut Struct__IO_cookie_file,
                           __read_write: ::std::os::raw::c_int,
                           __cookie: *mut ::std::os::raw::c_void,
                           __fns: _IO_cookie_io_functions_t);
    pub fn __underflow(arg1: *mut Struct__IO_FILE) -> ::std::os::raw::c_int;
    pub fn __uflow(arg1: *mut Struct__IO_FILE) -> ::std::os::raw::c_int;
    pub fn __overflow(arg1: *mut Struct__IO_FILE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn _IO_getc(__fp: *mut Struct__IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut Struct__IO_FILE)
     -> ::std::os::raw::c_int;
    pub fn _IO_feof(__fp: *mut Struct__IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_ferror(__fp: *mut Struct__IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_peekc_locked(__fp: *mut Struct__IO_FILE)
     -> ::std::os::raw::c_int;
    pub fn _IO_flockfile(arg1: *mut Struct__IO_FILE);
    pub fn _IO_funlockfile(arg1: *mut Struct__IO_FILE);
    pub fn _IO_ftrylockfile(arg1: *mut Struct__IO_FILE)
     -> ::std::os::raw::c_int;
    pub fn _IO_padn(arg1: *mut Struct__IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
    pub fn _IO_sgetn(arg1: *mut Struct__IO_FILE,
                     arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
    pub fn _IO_seekoff(arg1: *mut Struct__IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
    pub fn _IO_seekpos(arg1: *mut Struct__IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
    pub fn _IO_free_backup_area(arg1: *mut Struct__IO_FILE);
    pub fn remove(__filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn tmpfile() -> *mut FILE;
    pub fn tmpfile64() -> *mut FILE;
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fcloseall() -> ::std::os::raw::c_int;
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
    pub fn fopen64(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn freopen64(__filename: *const ::std::os::raw::c_char,
                     __modes: *const ::std::os::raw::c_char,
                     __stream: *mut FILE) -> *mut FILE;
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn fopencookie(__magic_cookie: *mut ::std::os::raw::c_void,
                       __modes: *const ::std::os::raw::c_char,
                       __io_funcs: _IO_cookie_io_functions_t) -> *mut FILE;
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: usize,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut usize) -> *mut FILE;
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: usize)
     -> ::std::os::raw::c_int;
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: usize);
    pub fn setlinebuf(__stream: *mut FILE);
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn __asprintf(__ptr: *mut *mut ::std::os::raw::c_char,
                      __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn asprintf(__ptr: *mut *mut ::std::os::raw::c_char,
                    __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getchar() -> ::std::os::raw::c_int;
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
    pub fn gets(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn fgets_unlocked(__s: *mut ::std::os::raw::c_char,
                          __n: ::std::os::raw::c_int, __stream: *mut FILE)
     -> *mut ::std::os::raw::c_char;
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut usize, __stream: *mut FILE) -> __ssize_t;
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __n: usize, __stream: *mut FILE) -> usize;
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __n: usize, __s: *mut FILE) -> usize;
    pub fn fputs_unlocked(__s: *const ::std::os::raw::c_char,
                          __stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                          __n: usize, __stream: *mut FILE) -> usize;
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: usize, __n: usize, __stream: *mut FILE)
     -> usize;
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
    pub fn rewind(__stream: *mut FILE);
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ftello(__stream: *mut FILE) -> __off_t;
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::std::os::raw::c_int;
    pub fn fseeko64(__stream: *mut FILE, __off: __off64_t,
                    __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ftello64(__stream: *mut FILE) -> __off64_t;
    pub fn fgetpos64(__stream: *mut FILE, __pos: *mut fpos64_t)
     -> ::std::os::raw::c_int;
    pub fn fsetpos64(__stream: *mut FILE, __pos: *const fpos64_t)
     -> ::std::os::raw::c_int;
    pub fn clearerr(__stream: *mut FILE);
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn clearerr_unlocked(__stream: *mut FILE);
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn perror(__s: *const ::std::os::raw::c_char);
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn cuserid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn obstack_printf(__obstack: *mut Struct_obstack,
                          __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn flockfile(__stream: *mut FILE);
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn funlockfile(__stream: *mut FILE);
    pub fn rt_fprintf(stream: *mut FILE,
                      format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn rt_printf(format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn rt_puts(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn rt_fputs(s: *const ::std::os::raw::c_char, stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn rt_fputc(c: ::std::os::raw::c_int, stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn rt_putchar(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rt_fwrite(ptr: *const ::std::os::raw::c_void, size: usize,
                     nmemb: usize, stream: *mut FILE) -> usize;
    pub fn rt_syslog(priority: ::std::os::raw::c_int,
                     format: *const ::std::os::raw::c_char, ...);
    pub fn rt_print_init(buffer_size: usize,
                         name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rt_print_cleanup();
    pub fn rt_print_auto_init(enable: ::std::os::raw::c_int);
    pub fn rt_print_buffer_name() -> *const ::std::os::raw::c_char;
    pub fn rt_print_flush_buffers();
    pub fn assert_nrt();
    /****************************************************************
 * gpio_functions
 ****************************************************************/
    #[link_name = "_Z10gpio_setupji"]
    pub fn gpio_setup(gpio: ::std::os::raw::c_uint,
                      out_flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    #[link_name = "_Z11gpio_exportj"]
    pub fn gpio_export(gpio: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    #[link_name = "_Z13gpio_unexportj"]
    pub fn gpio_unexport(gpio: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    #[link_name = "_Z12gpio_set_dirji"]
    pub fn gpio_set_dir(gpio: ::std::os::raw::c_uint,
                        out_flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    #[link_name = "_Z14gpio_set_valueji"]
    pub fn gpio_set_value(gpio: ::std::os::raw::c_uint,
                          value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    #[link_name = "_Z14gpio_get_valuejPj"]
    pub fn gpio_get_value(gpio: ::std::os::raw::c_uint,
                          value: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    #[link_name = "_Z13gpio_set_edgejPc"]
    pub fn gpio_set_edge(gpio: ::std::os::raw::c_uint,
                         edge: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    #[link_name = "_Z12gpio_fd_openji"]
    pub fn gpio_fd_open(gpio: ::std::os::raw::c_uint,
                        writeFlag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    #[link_name = "_Z13gpio_fd_closei"]
    pub fn gpio_fd_close(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[link_name = "_Z10gpio_writeii"]
    pub fn gpio_write(fd: ::std::os::raw::c_int, value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    #[link_name = "_Z9gpio_readiPj"]
    pub fn gpio_read(fd: ::std::os::raw::c_int,
                     value: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    #[link_name = "_Z12gpio_dismissij"]
    pub fn gpio_dismiss(fd: ::std::os::raw::c_int,
                        gpio: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    #[link_name = "_Z15led_set_triggerjPKc"]
    pub fn led_set_trigger(lednum: ::std::os::raw::c_uint,
                           trigger: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    /**
 * \brief User-defined initialisation function which runs before audio rendering begins.
 *
 * This function runs once at the beginning of the program, after most of the system
 * initialisation has begun but before audio rendering starts. Use it to prepare any
 * memory or resources that will be needed in render().
 *
 * \param context Data structure holding information on sample rates, numbers of channels,
 * frame sizes and other state. Note: the buffers for audio, analog and digital data will
 * \b not yet be available to use. Do not attempt to read or write audio or sensor data
 * in setup().
 * \param userData An opaque pointer to an optional user-defined data structure. Whatever
 * is passed as the second argument to Bela_initAudio() will appear here.
 *
 * \return true on success, or false if an error occurred. If no initialisation is
 * required, setup() should return true.
 */
    #[link_name = "_Z5setupP11BelaContextPv"]
    pub fn setup(context: *mut BelaContext,
                 userData: *mut ::std::os::raw::c_void) -> bool;
    /**
 * \brief User-defined callback function to process audio and sensor data.
 *
 * This function is called regularly by the system every time there is a new block of
 * audio and/or sensor data to process. Your code should process the requested samples
 * of data, store the results within \c context, and return.
 *
 * \param context Data structure holding buffers for audio, analog and digital data. The
 * structure also holds information on numbers of channels, frame sizes and sample rates,
 * which are guaranteed to remain the same throughout the program and to match what was
 * passed to setup().
 * \param userData An opaque pointer to an optional user-defined data structure. Will
 * be the same as the \c userData parameter passed to setup().
 */
    #[link_name = "_Z6renderP11BelaContextPv"]
    pub fn render(context: *mut BelaContext,
                  userData: *mut ::std::os::raw::c_void);
    /**
 * \brief User-defined cleanup function which runs when the program finishes.
 *
 * This function is called by the system once after audio rendering has finished, before the
 * program quits. Use it to release any memory allocated in setup() and to perform
 * any other required cleanup. If no initialisation is performed in setup(), then
 * this function will usually be empty.
 *
 * \param context Data structure holding information on sample rates, numbers of channels,
 * frame sizes and other state. Note: the buffers for audio, analog and digital data will
 * no longer be available to use. Do not attempt to read or write audio or sensor data
 * in cleanup().
 * \param userData An opaque pointer to an optional user-defined data structure. Will
 * be the same as the \c userData parameter passed to setup() and render().
 */
    #[link_name = "_Z7cleanupP11BelaContextPv"]
    pub fn cleanup(context: *mut BelaContext,
                   userData: *mut ::std::os::raw::c_void);
    /**
 * \brief Initialise the data structure containing settings for Bela.
 *
 * This function should be called in main() before parsing any command-line arguments. It
 * sets default values in the data structure which specifies the Bela settings, including
 * frame sizes, numbers of channels, volume levels and other parameters.
 *
 * \param settings Structure holding initialisation data for Bela.
 */
    #[link_name = "_Z20Bela_defaultSettingsP16BelaInitSettings"]
    pub fn Bela_defaultSettings(settings: *mut BelaInitSettings);
    /**
 * \brief Get long options from command line argument list, including Bela standard options
 *
 * This function should be used in main() to process command line options, in place of the
 * standard library getopt_long(). Internally, it parses standard Bela command-line options,
 * storing the results in the settings data structure. Any options which are not part of the
 * Bela standard options will be returned, as they would normally be in getopt_long().
 *
 * \param argc Number of command line options, as passed to main().
 * \param argv Array of command line options, as passed to main().
 * \param customShortOptions List of short options to be parsed, analogous to getopt_long(). This
 * list should not include any characters already parsed as part of the Bela standard options.
 * \param customLongOptions List of long options to parsed, analogous to getopt_long(). This
 * list should not include any long options already parsed as part of the Bela standard options.
 * \param settings Data structure holding initialisation settings for Bela. Any standard options
 * parsed will automatically update this data structure.
 *
 * \return Value of the next option parsed which is not a Bela standard option, or -1 when the
 * argument list has been exhausted. Similar to the return value of getopt_long() except that Bela
 * standard options are handled internally and not returned.
 */
    #[link_name = "_Z16Bela_getopt_longiPPcPKcPK6optionP16BelaInitSettings"]
    pub fn Bela_getopt_long(argc: ::std::os::raw::c_int,
                            argv: *mut *mut ::std::os::raw::c_char,
                            customShortOptions: *const ::std::os::raw::c_char,
                            customLongOptions: *const Struct_option,
                            settings: *mut BelaInitSettings)
     -> ::std::os::raw::c_int;
    /**
 * \brief Print usage information for Bela standard options.
 *
 * This function should be called from your code wherever you wish to print usage information for the
 * user. It will print usage information on Bela standard options, after which you can print usage
 * information for your own custom options.
 */
    #[link_name = "_Z10Bela_usagev"]
    pub fn Bela_usage();
    /**
 * \brief Set level of verbose (debugging) printing.
 *
 * \param level Verbosity level of the internal Bela system. 0 by default; higher values will
 * print more information. Presently all positive numbers produce the same level of printing.
 */
    #[link_name = "_Z20Bela_setVerboseLeveli"]
    pub fn Bela_setVerboseLevel(level: ::std::os::raw::c_int);
    /**
 * \brief Initialise audio and sensor rendering environment.
 *
 * This function prepares audio rendering in Bela. It should be called from main() sometime
 * after command line option parsing has finished. It will initialise the rendering system, which
 * in the process will result in a call to the user-defined setup() function.
 *
 * \param settings Data structure holding system settings, including numbers of channels, frame sizes,
 * volume levels and other information.
 * \param userData An opaque pointer to a user-defined data structure which will be passed to
 * setup(), render() and cleanup(). You can use this to pass custom information
 * to the rendering functions, as an alternative to using global variables.
 *
 * \return 0 on success, or nonzero if an error occurred.
 */
    #[link_name = "_Z14Bela_initAudioP16BelaInitSettingsPv"]
    pub fn Bela_initAudio(settings: *mut BelaInitSettings,
                          userData: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    /**
 * \brief Begin processing audio and sensor data.
 *
 * This function will start the Bela audio/sensor system. After this function is called, the
 * system will make periodic calls to render() until Bela_stopAudio() is called.
 *
 * \return 0 on success, or nonzero if an error occurred.
 */
    #[link_name = "_Z15Bela_startAudiov"]
    pub fn Bela_startAudio() -> ::std::os::raw::c_int;
    /**
 * \brief Stop processing audio and sensor data.
 *
 * This function will stop the Bela audio/sensor system. After this function returns, no further
 * calls to render() will be issued.
 */
    #[link_name = "_Z23Bela_startAuxiliaryTaskPv"]
    pub fn Bela_startAuxiliaryTask(task: AuxiliaryTask)
     -> ::std::os::raw::c_int;
    #[link_name = "_Z14Bela_stopAudiov"]
    pub fn Bela_stopAudio();
    /**
 * \brief Clean up resources from audio and sensor processing.
 *
 * This function should only be called after Bela_stopAudio(). It will release any
 * internal resources for audio and sensor processing. In the process, it will call the
 * user-defined cleanup() function.
 */
    #[link_name = "_Z17Bela_cleanupAudiov"]
    pub fn Bela_cleanupAudio();
    /**
 * \brief Set the level of the audio DAC.
 *
 * This function sets the level of all audio outputs (headphone, line, speaker). It does
 * not affect the level of the (non-audio) analog outputs.
 *
 * \b Important: do not call this function from within render(), as it does not make
 * any guarantees on real-time performance.
 *
 * \param decibels Level of the DAC output. Valid levels range from -63.5 (lowest) to
 * 0 (highest) in steps of 0.5dB. Levels between increments of 0.5 will be rounded down.
 *
 * \return 0 on success, or nonzero if an error occurred.
 */
    #[link_name = "_Z16Bela_setDACLevelf"]
    pub fn Bela_setDACLevel(decibels: f32) -> ::std::os::raw::c_int;
    /**
 * \brief Set the level of the audio ADC.
 *
 * This function sets the level of the audio input. It does not affect the level of the
 * (non-audio) analog inputs.
 *
 * \b Important: do not call this function from within render(), as it does not make
 * any guarantees on real-time performance.
 *
 * \param decibels Level of the ADC input. Valid levels range from -12 (lowest) to
 * 0 (highest) in steps of 1.5dB. Levels between increments of 1.5 will be rounded down.
 *
 * \return 0 on success, or nonzero if an error occurred.
 */
    #[link_name = "_Z16Bela_setADCLevelf"]
    pub fn Bela_setADCLevel(decibels: f32) -> ::std::os::raw::c_int;
    /**
 * \brief Set the gain of the audio preamplifier.
 *
 * This function sets the level of the Programmable Gain Amplifier(PGA), which
 * amplifies the signal before the ADC.
 *
 * \b Important: do not call this function from within render(), as it does not make
 * any guarantees on real-time performance.
 *
 * \param decibels Level of the PGA Valid levels range from 0 (lowest) to
 * 59.5 (highest) in steps of 0.5dB. Levels between increments of 0.5 will be rounded.
 * \param channel Specifies which channel to apply the gain to. Channel 0 is left,
 * channel 1 is right
 *
 * \return 0 on success, or nonzero if an error occurred.
 */
    #[link_name = "_Z15Bela_setPgaGainfi"]
    pub fn Bela_setPgaGain(decibels: f32, channel: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    /**
 * \brief Set the level of the onboard headphone amplifier.
 *
 * This function sets the level of the headphone output only (3-pin connector on the Bela
 * cape or the output jack on the BeagleBone Audio Cape). It does not affect the level of the
 * speakers or the line out pads on the cape.
 *
 * \b Important: do not call this function from within render(), as it does not make
 * any guarantees on real-time performance.
 *
 * \param decibels Level of the DAC output. Valid levels range from -63.5 (lowest) to
 * 0 (highest) in steps of 0.5dB. Levels between increments of 0.5 will be rounded down.
 *
 * \return 0 on success, or nonzero if an error occurred.
 */
    #[link_name = "_Z22Bela_setHeadphoneLevelf"]
    pub fn Bela_setHeadphoneLevel(decibels: f32) -> ::std::os::raw::c_int;
    /**
 * \brief Mute or unmute the onboard speaker amplifiers.
 *
 * This function mutes or unmutes the amplifiers on the Bela cape. Whether the speakers begin
 * muted or unmuted depends on the BelaInitSettings structure passed to Bela_initAudio().
 *
 * \b Important: do not call this function from within render(), as it does not make
 * any guarantees on real-time performance.
 *
 * \param mute 0 to enable the speakers, nonzero to mute the speakers.
 *
 * \return 0 on success, or nonzero if an error occurred.
 */
    #[link_name = "_Z17Bela_muteSpeakersi"]
    pub fn Bela_muteSpeakers(mute: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    /**
 * \brief Create a new auxiliary task.
 *
 * This function creates a new auxiliary task which, when scheduled, runs the function specified
 * in the first argument. Note that the task does not run until scheduleAuxiliaryTask() is called.
 * Auxiliary tasks should be created in setup() and never in render() itself.
 *
 * The second argument specifies the real-time priority. Valid values are between 0
 * and 99, and usually should be lower than \ref BELA_AUDIO_PRIORITY. Tasks with higher priority always
 * preempt tasks with lower priority.
 *
 * \param functionToCall Function which will run each time the auxiliary task is scheduled.
 * \param priority Xenomai priority level at which the task should run.
 * \param name Name for this task, which should be unique system-wide (no other running program should use this name).
 */
    #[link_name = "_Z24Bela_createAuxiliaryTaskPFvPvEiPKcS_b"]
    pub fn Bela_createAuxiliaryTask(functionToCall:
                                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                       *mut ::std::os::raw::c_void)>,
                                    priority: ::std::os::raw::c_int,
                                    name: *const ::std::os::raw::c_char,
                                    args: *mut ::std::os::raw::c_void,
                                    autoSchedule: bool) -> AuxiliaryTask;
    #[link_name = "_Z24Bela_createAuxiliaryTaskPFvvEiPKcb"]
    pub fn Bela_createAuxiliaryTask1(functionToCall:
                                         ::std::option::Option<unsafe extern "C" fn()>,
                                     priority: ::std::os::raw::c_int,
                                     name: *const ::std::os::raw::c_char,
                                     autoSchedule: bool) -> AuxiliaryTask;
    /**
 * \brief Run an auxiliary task which has previously been created.
 *
 * This function will schedule an auxiliary task to run. When the task runs, the function in the first
 * argument of createAuxiliaryTaskLoop() will be called.
 *
 * scheduleAuxiliaryTask() is typically called from render() to start a lower-priority task. The function
 * will not run immediately, but only once any active higher priority tasks have finished.
 *
 * \param task Task to schedule for running.
 */
    #[link_name = "_Z26Bela_scheduleAuxiliaryTaskPv"]
    pub fn Bela_scheduleAuxiliaryTask(task: AuxiliaryTask);
    #[link_name = "_Z31Bela_autoScheduleAuxiliaryTasksv"]
    pub fn Bela_autoScheduleAuxiliaryTasks();
}

